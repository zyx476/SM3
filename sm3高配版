#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

// 常量定义
#define SM3_DIGEST_LENGTH 32
#define SM3_BLOCK_SIZE 64

// 消息分组结构
typedef struct {
    uint32_t state[8];          // 压缩函数中间状态
    uint64_t totalLength;       // 消息总长度(bit)
    uint8_t buffer[SM3_BLOCK_SIZE]; // 消息缓冲区
    int bufferLength;           // 缓冲区中的字节数
} SM3_CTX;

// 常量T_j
#define T(j)  (j < 16 ? 0x79CC4519 : 0x7A879D8A)

// 循环左移
#define ROTL(X, n)  (((X) << (n)) | ((X) >> (32 - (n))))

// 布尔函数
#define FF0(X, Y, Z)  ((X) ^ (Y) ^ (Z))
#define FF1(X, Y, Z)  (((X) & (Y)) | (X) & (Z) | (Y) & (Z))
#define GG0(X, Y, Z)  ((X) ^ (Y) ^ (Z))
#define GG1(X, Y, Z)  (((X) & (Y)) | (~(X) & (Z)))

// 置换函数
#define P0(X)  ((X) ^ ROTL(X, 9) ^ ROTL(X, 17))
#define P1(X)  ((X) ^ ROTL(X, 15) ^ ROTL(X, 23))

// 初始化函数
void SM3_Init(SM3_CTX* ctx) {
    ctx->state[0] = 0x7380166F;
    ctx->state[1] = 0x4914B2B9;
    ctx->state[2] = 0x172442D7;
    ctx->state[3] = 0xDA8A0600;
    ctx->state[4] = 0xA96F30BC;
    ctx->state[5] = 0x163138AA;
    ctx->state[6] = 0xE38DEE4D;
    ctx->state[7] = 0xB0FB0E4E;
    ctx->totalLength = 0;
    ctx->bufferLength = 0;
}

// 压缩函数
static void SM3_Compress(SM3_CTX* ctx, const uint8_t block[SM3_BLOCK_SIZE]) {
    uint32_t W[68], W1[64];
    uint32_t A, B, C, D, E, F, G, H;
    uint32_t SS1, SS2, TT1, TT2;
    int i;

    // 消息扩展
    for (i = 0; i < 16; i++) {
        W[i] = (block[4 * i] << 24) | (block[4 * i + 1] << 16) |
            (block[4 * i + 2] << 8) | block[4 * i + 3];
    }

    for (i = 16; i < 68; i++) {
        W[i] = P1(W[i - 16] ^ W[i - 9] ^ ROTL(W[i - 3], 15)) ^
            ROTL(W[i - 13], 7) ^ W[i - 6];
    }

    for (i = 0; i < 64; i++) {
        W1[i] = W[i] ^ W[i + 4];
    }

    // 初始化工作变量
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    // 64轮迭代
    for (i = 0; i < 64; i++) {
        SS1 = ROTL(ROTL(A, 12) + E + ROTL(T(i), i), 7);
        SS2 = SS1 ^ ROTL(A, 12);
        TT1 = (i < 16 ? FF0(A, B, C) : FF1(A, B, C)) + D + SS2 + W1[i];
        TT2 = (i < 16 ? GG0(E, F, G) : GG1(E, F, G)) + H + SS1 + W[i];
        D = C;
        C = ROTL(B, 9);
        B = A;
        A = TT1;
        H = G;
        G = ROTL(F, 19);
        F = E;
        E = P0(TT2);
    }

    // 更新状态
    ctx->state[0] ^= A;
    ctx->state[1] ^= B;
    ctx->state[2] ^= C;
    ctx->state[3] ^= D;
    ctx->state[4] ^= E;
    ctx->state[5] ^= F;
    ctx->state[6] ^= G;
    ctx->state[7] ^= H;
}

// 更新函数，处理输入数据
void SM3_Update(SM3_CTX* ctx, const uint8_t* data, size_t length) {
    size_t i;

    // 处理输入数据
    for (i = 0; i < length; i++) {
        ctx->buffer[ctx->bufferLength++] = data[i];
        if (ctx->bufferLength == SM3_BLOCK_SIZE) {
            SM3_Compress(ctx, ctx->buffer);
            ctx->totalLength += 8 * SM3_BLOCK_SIZE;
            ctx->bufferLength = 0;
        }
    }
}

// 最终处理函数，生成哈希值
void SM3_Final(uint8_t digest[SM3_DIGEST_LENGTH], SM3_CTX* ctx) {
    int i;
    uint64_t bitLength;

    // 记录消息总长度(bit)
    bitLength = ctx->totalLength + (uint64_t)ctx->bufferLength * 8;

    // 填充
    ctx->buffer[ctx->bufferLength++] = 0x80;

    // 如果剩余空间不足以存放长度信息，则先处理一个块
    if (ctx->bufferLength > SM3_BLOCK_SIZE - 8) {
        memset(ctx->buffer + ctx->bufferLength, 0, SM3_BLOCK_SIZE - ctx->bufferLength);
        SM3_Compress(ctx, ctx->buffer);
        ctx->bufferLength = 0;
    }

    // 填充0
    memset(ctx->buffer + ctx->bufferLength, 0, SM3_BLOCK_SIZE - 8 - ctx->bufferLength);

    // 附加长度信息
    for (i = 0; i < 8; i++) {
        ctx->buffer[SM3_BLOCK_SIZE - 8 + i] = (uint8_t)(bitLength >> (8 * (7 - i)));
    }

    // 处理最后一个块
    SM3_Compress(ctx, ctx->buffer);

    // 将状态转换为哈希值
    for (i = 0; i < 8; i++) {
        digest[4 * i] = (uint8_t)(ctx->state[i] >> 24);
        digest[4 * i + 1] = (uint8_t)(ctx->state[i] >> 16);
        digest[4 * i + 2] = (uint8_t)(ctx->state[i] >> 8);
        digest[4 * i + 3] = (uint8_t)ctx->state[i];
    }
}

// 便捷函数：直接计算数据的SM3哈希值
void SM3(const uint8_t* data, size_t length, uint8_t digest[SM3_DIGEST_LENGTH]) {
    SM3_CTX ctx;
    SM3_Init(&ctx);
    SM3_Update(&ctx, data, length);
    SM3_Final(digest, &ctx);
}

// 测试函数
int main() {
    // 测试向量1：空字符串
    uint8_t digest1[SM3_DIGEST_LENGTH];
    SM3((const uint8_t*)"", 0, digest1);
    printf("空字符串的SM3哈希值: ");
    for (int i = 0; i < SM3_DIGEST_LENGTH; i++) {
        printf("%02x", digest1[i]);
    }
    printf("\n");

    // 测试向量2："abc"
    uint8_t digest2[SM3_DIGEST_LENGTH];
    SM3((const uint8_t*)"abc", 3, digest2);
    printf("\"abc\"的SM3哈希值:   ");
    for (int i = 0; i < SM3_DIGEST_LENGTH; i++) {
        printf("%02x", digest2[i]);
    }
    printf("\n");

    // 测试向量3：重复的"abcd"字符串
    const char* testStr = "abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd";
    uint8_t digest3[SM3_DIGEST_LENGTH];
    SM3((const uint8_t*)testStr, strlen(testStr), digest3);
    printf("重复\"abcd\"的SM3哈希值: ");
    for (int i = 0; i < SM3_DIGEST_LENGTH; i++) {
        printf("%02x", digest3[i]);
    }
    printf("\n");

    return 0;
}
